tree grammar RuleOutputWalker;

options {

    // Default language but name it anyway
    //
    language  = Java;

    // Use the vocabulary generated by the accompanying
    // lexer. Maven knows how to work out the relationship
    // between the lexer and parser and will build the 
    // lexer before the parser. It will also rebuild the
    // parser if the lexer changes.
    //
    tokenVocab = RuleParser;
    
    ASTLabelType = CommonTree;
    
    backtrack = true;
    memoize = true;
}

@header {

    package com.sri.ai.praise.rules.antlr;

    import java.util.List;
    import java.util.Vector;

    import com.sri.ai.expresso.api.Expression;
    import com.sri.ai.expresso.core.DefaultSymbol;
    import com.sri.ai.expresso.core.DefaultCompoundSyntaxTree;
}


/*
    The ANTLR output tree walker is the final step in parsing the LPI grammar.
    The walker converts the AST from ANTLR's native CommonTree node type to
    the expected DefaultCompoundSyntaxTree/DefaultSymbol output.  It walks
    the CommonTree AST and at every node, generates the appropriate output
    node object.

    Adding new grammar rules
    ------------------------
    Add a converter under the expr rule to handle the new node types for the 
    new rules.  Make sure the children of the node types are declared as expr
    to ensure that the walker will invoke the expr rule on all the children.
*/
start returns [List<Expression> value]
@init {
    $value = new Vector<Expression>();
}
    : (a=expr { value.add(a); })* EOF 
    ;

expr returns [Expression value]
@init {
    Vector<Expression> varargs = new Vector<Expression>();
}
    : 
      ^(POTENTIALEXPRESSION1 a=expr)                      { $value = new DefaultCompoundSyntaxTree("atomic rule", a, 1); }
    | ^(POTENTIALEXPRESSION2 a=expr b=expr)               { $value = new DefaultCompoundSyntaxTree("atomic rule", a, b); }

    | ^(CONDITIONALEXPRESSION1 a=expr b=expr)             { $value = new DefaultCompoundSyntaxTree("conditional rule", a, b); }
    | ^(CONDITIONALEXPRESSION2 a=expr b=expr c=expr)      { $value = new DefaultCompoundSyntaxTree("conditional rule", a, b, c); }

    | ^(PROLOGEXPRESSION4 a=expr b=expr c=expr)           { $value = new DefaultCompoundSyntaxTree("prolog rule", a, b, c); }
    | ^(PROLOGEXPRESSION3 a=expr b=expr)                  { $value = new DefaultCompoundSyntaxTree("prolog rule", a, b); }
    | ^(PROLOGEXPRESSION2 a=expr b=expr)                  { $value = new DefaultCompoundSyntaxTree("prolog rule", 1, a, b); }
    | ^(PROLOGEXPRESSION1 a=expr)                         { $value = new DefaultCompoundSyntaxTree("prolog rule", 1, a); }

    | ^(RANDOM (a=expr {varargs.add(a); })+)              { varargs.insertElementAt(DefaultSymbol.createSymbol(varargs.size()-2), 1);
                                                            $value = new DefaultCompoundSyntaxTree("randomVariable", varargs); }
    | ^(SORT a=expr b=expr c=expr)                        { $value = new DefaultCompoundSyntaxTree("sort", a, b, c); }

    | ^(FORALL a=expr b=expr)                             { $value = new DefaultCompoundSyntaxTree("for all . : .", a, b); }
    | ^(THEREEXISTS a=expr b=expr)                        { $value = new DefaultCompoundSyntaxTree("there exists . : .", a, b); }
    | ^(ARROW (a=expr {varargs.add(a); })*)               { $value = new DefaultCompoundSyntaxTree("=>", varargs); }
    | ^(DOUBLE_ARROW (a=expr {varargs.add(a); })*)        { $value = new DefaultCompoundSyntaxTree("<=>", varargs); }
    | ^(OR (a=expr {varargs.add(a); })*)                  { $value = new DefaultCompoundSyntaxTree("or", varargs); }
    | ^(AND (a=expr {varargs.add(a); })*)                 { $value = new DefaultCompoundSyntaxTree("and", varargs); }
    | ^(EQUAL (a=expr {varargs.add(a); })*)               { $value = new DefaultCompoundSyntaxTree("=", varargs); }
    | ^(NOT_EQUAL (a=expr {varargs.add(a); })*)           { $value = new DefaultCompoundSyntaxTree("!=", varargs); }
    | ^(PLUS (a=expr {varargs.add(a); })*)                { $value = new DefaultCompoundSyntaxTree("+", varargs); }
    | ^(DASH (a=expr {varargs.add(a); })*)                { $value = new DefaultCompoundSyntaxTree("-", varargs); }
    | ^(MINUS (a=expr {varargs.add(a); })*)               { $value = new DefaultCompoundSyntaxTree("minus", varargs); }
    | ^(TIMES (a=expr {varargs.add(a); })*)               { $value = new DefaultCompoundSyntaxTree("*", varargs); }
    | ^(DIVIDE (a=expr {varargs.add(a); })*)              { $value = new DefaultCompoundSyntaxTree("/", varargs); }
    | ^(CARAT (a=expr {varargs.add(a); })*)               { $value = new DefaultCompoundSyntaxTree("^", varargs); }
    | ^(NOT (a=expr {varargs.add(a); })*)                 { $value = new DefaultCompoundSyntaxTree("not", varargs); }
    | ^(SET a=expr)                                       { $value = new DefaultCompoundSyntaxTree("{ . }", a); }
    | ^(MAYBESAMEAS (a=expr {varargs.add(a); })*)         { $value = new DefaultCompoundSyntaxTree("may be same as", varargs); }
    | ^(FUNCTION a=expr (b=expr {varargs.add(b); })*)     { $value = new DefaultCompoundSyntaxTree(a, varargs); }
    | ^(SYMBOL ID)                                        { $value = DefaultSymbol.createSymbol($ID.text); }
    | ^(SET a=expr)                                       { $value = new DefaultCompoundSyntaxTree("{ . }", a); }
    | ^(KLEENE (a=expr { varargs.add(a); })*)             { $value = new DefaultCompoundSyntaxTree("kleene list", varargs); }
    ;


