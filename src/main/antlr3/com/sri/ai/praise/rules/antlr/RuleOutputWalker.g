tree grammar RuleOutputWalker;

options {

    // Default language but name it anyway
    //
    language  = Java;

    // Use the vocabulary generated by the accompanying
    // lexer. Maven knows how to work out the relationship
    // between the lexer and parser and will build the 
    // lexer before the parser. It will also rebuild the
    // parser if the lexer changes.
    //
    tokenVocab = RuleParser;
    
    ASTLabelType = CommonTree;
    
    backtrack = true;
    memoize = true;
}

@header {

    package com.sri.ai.praise.rules.antlr;

    import java.util.List;
    import java.util.Vector;

    import com.sri.ai.expresso.api.Expression;
    import com.sri.ai.expresso.helper.SyntaxTrees;
}


/*
    The ANTLR output tree walker is the final step in parsing the LPI grammar.
    The walker converts the AST from ANTLR's native CommonTree node type to
    the expected CompoundSyntaxTree/Symbol output.  It walks
    the CommonTree AST and at every node, generates the appropriate output
    node object.

    Adding new grammar rules
    ------------------------
    Add a converter under the expr rule to handle the new node types for the 
    new rules.  Make sure the children of the node types are declared as expr
    to ensure that the walker will invoke the expr rule on all the children.
*/
start returns [List<Expression> value]
@init {
    $value = new Vector<Expression>();
}
    : (a=expr { value.add(a); })* EOF 
    ;

expr returns [Expression value]
@init {
    Vector<Expression> varargs = new Vector<Expression>();
}
    : 
      ^(POTENTIALEXPRESSION1 a=expr)                        { $value = SyntaxTrees.makeCompoundSyntaxTree("atomic rule", a, 1); }
    | ^(POTENTIALEXPRESSION2 a=expr b=expr)                 { $value = SyntaxTrees.makeCompoundSyntaxTree("atomic rule", a, b); }

    | ^(CONDITIONALEXPRESSION1 a=expr b=expr)               { $value = SyntaxTrees.makeCompoundSyntaxTree("conditional rule", a, b); }
    | ^(CONDITIONALEXPRESSION2 a=expr b=expr c=expr)        { $value = SyntaxTrees.makeCompoundSyntaxTree("conditional rule", a, b, c); }

    | ^(PROLOGEXPRESSION4 a=expr b=expr c=expr)             { $value = SyntaxTrees.makeCompoundSyntaxTree("prolog rule", a, b, c); }
    | ^(PROLOGEXPRESSION3 a=expr b=expr)                    { $value = SyntaxTrees.makeCompoundSyntaxTree("prolog rule", a, b); }
    | ^(PROLOGEXPRESSION2 a=expr b=expr)                    { $value = SyntaxTrees.makeCompoundSyntaxTree("prolog rule", 1, a, b); }
    | ^(PROLOGEXPRESSION1 a=expr)                           { $value = SyntaxTrees.makeCompoundSyntaxTree("prolog rule", 1, a); }

    | ^(STANDARDPROBABILITYEXPRESSION a=expr b=expr c=expr) { $value = SyntaxTrees.makeCompoundSyntaxTree("standard probability rule", a, b, c); }
    | ^(CAUSALEXPRESSION a=expr b=expr)                     { $value = SyntaxTrees.makeCompoundSyntaxTree("causal rule", a, b); }

    // For conjunctions, we package it as a tuple.
    | ^(CONJUNCTION (a=expr {varargs.add(a); })*)           { $value = SyntaxTrees.makeCompoundSyntaxTree("( . )", 
                                                                  SyntaxTrees.makeCompoundSyntaxTree("kleene list", varargs)); }

    | ^(RANDOM (a=expr {varargs.add(a); })+)                { varargs.insertElementAt(SyntaxTrees.makeSymbol(varargs.size()-2), 1);
                                                              $value = SyntaxTrees.makeCompoundSyntaxTree("randomVariable", varargs); }
    | ^(SORT a=expr b=expr c=expr)                          { $value = SyntaxTrees.makeCompoundSyntaxTree("sort", a, b, c); }

    | ^(FORALL a=expr b=expr)                               { $value = SyntaxTrees.makeCompoundSyntaxTree("for all . : .", a, b); }
    | ^(THEREEXISTS a=expr b=expr)                          { $value = SyntaxTrees.makeCompoundSyntaxTree("there exists . : .", a, b); }
    | ^(ARROW (a=expr {varargs.add(a); })*)                 { $value = SyntaxTrees.makeCompoundSyntaxTree("=>", varargs); }
    | ^(DOUBLE_ARROW (a=expr {varargs.add(a); })*)          { $value = SyntaxTrees.makeCompoundSyntaxTree("<=>", varargs); }
    | ^(OR (a=expr {varargs.add(a); })*)                    { $value = SyntaxTrees.makeCompoundSyntaxTree("or", varargs); }
    | ^(AND (a=expr {varargs.add(a); })*)                   { $value = SyntaxTrees.makeCompoundSyntaxTree("and", varargs); }
    | ^(EQUAL (a=expr {varargs.add(a); })*)                 { $value = SyntaxTrees.makeCompoundSyntaxTree("=", varargs); }
    | ^(NOT_EQUAL (a=expr {varargs.add(a); })*)             { $value = SyntaxTrees.makeCompoundSyntaxTree("!=", varargs); }
    | ^(PLUS (a=expr {varargs.add(a); })*)                  { $value = SyntaxTrees.makeCompoundSyntaxTree("+", varargs); }
    | ^(DASH (a=expr {varargs.add(a); })*)                  { $value = SyntaxTrees.makeCompoundSyntaxTree("-", varargs); }
    | ^(MINUS (a=expr {varargs.add(a); })*)                 { $value = SyntaxTrees.makeCompoundSyntaxTree("minus", varargs); }
    | ^(TIMES (a=expr {varargs.add(a); })*)                 { $value = SyntaxTrees.makeCompoundSyntaxTree("*", varargs); }
    | ^(DIVIDE (a=expr {varargs.add(a); })*)                { $value = SyntaxTrees.makeCompoundSyntaxTree("/", varargs); }
    | ^(CARAT (a=expr {varargs.add(a); })*)                 { $value = SyntaxTrees.makeCompoundSyntaxTree("^", varargs); }
    | ^(NOT (a=expr {varargs.add(a); })*)                   { $value = SyntaxTrees.makeCompoundSyntaxTree("not", varargs); }
    | ^(SET a=expr)                                         { $value = SyntaxTrees.makeCompoundSyntaxTree("{ . }", a); }
    | ^(MAYBESAMEAS (a=expr {varargs.add(a); })*)           { $value = SyntaxTrees.makeCompoundSyntaxTree(". may be same as .", varargs); }
    | ^(FUNCTION a=expr (b=expr {varargs.add(b); })*)       { $value = SyntaxTrees.makeCompoundSyntaxTree(a, varargs); }
    | ^(SYMBOL ID)                                          { $value = SyntaxTrees.makeSymbol($ID.text); }
    | ^(SET a=expr)                                         { $value = SyntaxTrees.makeCompoundSyntaxTree("{ . }", a); }
    | ^(KLEENE (a=expr { varargs.add(a); })*)               { $value = SyntaxTrees.makeCompoundSyntaxTree("kleene list", varargs); }
    ;


