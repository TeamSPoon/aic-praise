tree grammar RuleAssociativeNodeWalker;

options {

    // Default language but name it anyway
    //
    language  = Java;

    // Use the vocabulary generated by the accompanying
    // lexer. Maven knows how to work out the relationship
    // between the lexer and parser and will build the 
    // lexer before the parser. It will also rebuild the
    // parser if the lexer changes.
    //
    tokenVocab = RuleParser;
    
    ASTLabelType = CommonTree;
    output=AST;
    filter=true;
    //backtrack = true;
    //memoize = true;
}

@header {
    package com.sri.ai.praise.rules.antlr;
}


/*
    In this tree walker we're consolidating associative nodes into
    a single node with all the operands children under the one node.
    For example, 1 + 2 + 3 + 4 would come out of the parser with this
    tree structure:
            +
           / \
          +   4
         / \
        +   3
       / \
      1   2

    But after this tree walker does its work, the tree looks like this:
            +
         / / \ \
        1 2   3 4
    
    The way it works is using a pattern in ANTLR.  When the tree walker 
    output is AST and filtering is turned on, ANTLR will create a
    method called downup(), which calls two methods, topdown and bottomup.
    topdown is called once as it walks down to each node in the tree and
    bottomup is called when walking back up the tree.  More info can be
    found here:
    http://www.antlr.org/wiki/display/ANTLR3/Tree+pattern+matching
    http://www.antlr.org/wiki/display/~admin/2008/11/29/Woohoo!+Tree+pattern+matching%2C+rewriting+a+reality
    http://www.antlr.org/wiki/display/~admin/2008/11/30/Example+tree+rewriting+with+patterns
    
    We don't need to do anything on the way down, so there is no 
    topdown rule.  In the bottomup rule, we look for consecutive 
    instances of the associative operator types and consolidate them.
    We only have to look for the same node type in the first child
    slot because that is how they will come out of the parser as 
    illustrated above.
    
    Adding new grammar rules
    ------------------------
    If the new rule is associative, add it to the bottonup rule below
    as an alternative pattern to match against.  Follow the basic format 
    of the existing patterns:
        ^(FOO ^(FOO (a+=.)+) b=.)  ->  ^(FOO ($a)+ $b)
*/
bottomup
    : ^(TIMES        ^(TIMES        (a+=.)+) b=.)  ->  ^(TIMES        ($a)+ $b)
    | ^(PLUS         ^(PLUS         (a+=.)+) b=.)  ->  ^(PLUS         ($a)+ $b)
    | ^(EQUAL        ^(EQUAL        (a+=.)+) b=.)  ->  ^(EQUAL        ($a)+ $b)
    | ^(AND          ^(AND          (a+=.)+) b=.)  ->  ^(AND          ($a)+ $b)
    | ^(OR           ^(OR           (a+=.)+) b=.)  ->  ^(OR           ($a)+ $b)
    ;

